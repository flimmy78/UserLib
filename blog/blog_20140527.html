<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
      "http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="UserLib is a C++ Library with a C-Kernel."> 
    <meta name="keywords" content="Library, C++"> 
    <meta name="robots" content="index|follow"> 
    <title>Userlib by okdevdo</title>

    <link rel="stylesheet" href="../stylesheets/styles.css">
    <link rel="stylesheet" href="../stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Modern C++</h1>
        <p><a href="http://en.wikipedia.org/wiki/C%2B%2B">C++</a> is one of the programming languages most used. It is standardized by <a href="https://isocpp.org/">ISO</a> organisation.</p>
		
        <ul>
          <li><a href="">Back</a></li>
          <li><a href="../index.html">Home</a></li>
          <li><a href="">Next</a></li>
        </ul>
      </header>
      <section>
	  <h2>Smart Pointers</h2>
	  <p>In the <a href="http://en.cppreference.com/w/">standard library of C++11</a> you find the following <a href="http://en.wikipedia.org/wiki/Smart_pointer">smart pointers</a>: unique_ptr, shared_ptr and weak_ptr. unique_ptr is an advancement of old auto_ptr. auto_ptr has a copy semantic, while unique_ptr has a modern move semantic. shared_ptr and weak_ptr implement the counted reference pointer idiom.</p>
	  <p>UserLib contains class <a href="../html/_cpp_object_8h_source.html">CCppObject</a>, which is the base class of all classes allocated on the managed heap. Associated is smart pointer class <a href="../html/_cpp_object_8h_source.html">CCppObjectPtr</a>, which is an intrusive pointer.</p>
	  <h2>Containers</h2>
	  <p>The <a href="http://en.wikipedia.org/wiki/Standard_Template_Library">standard template library</a> supports four categories: containers, algorithms, functors and iterators. Containers can be divided into two groups: sequential and associative containers. Sequence containers include vector, deque, and list. Associative containers include set, multiset, map, and multimap.</p>
	  <p>UserLib contains several templated wrapper classes. Wrapper classes of a interface and implementation of data structures written in C. This list include <a href="../html/_data_array_8h_source.html">CDataArray</a>, <a href="../html/_data_vector_8h_source.html">CDataVector</a>, <a href="../html/_data_double_linked_list_8h_source.html">CDataDoubleLinkedList</a>, <a href="../html/_data_binary_tree_8h_source.html">CDataBinaryTree</a> and <a href="../html/_data_b_tree_8h_source.html">CDataBTree</a>. Each class defines its own iterator. And the set of methods forming the interface are very similar to each other. For example the interface of <a href="../html/_data_vector_8h_source.html">CDataVector</a> is as follows:</p>
	  <table>
		<tr><td><code>bool Open(TListCnt cnt, TListCnt exp);</code></td></tr>
		<tr><td><code>TListCnt Count() const;</code></td></tr>
		<tr><td><code>void Close();</code></td></tr>
		<tr><td><code>template &lt;typename D&gt; void Close(RefRef(D) rD = D());</code></td></tr>
		<tr><td><code>template &lt;typename D&gt; void Close(Ref(D) rD)</code></td></tr>
		<tr><td>Open allocates the list. Close disposes it. Template parameter D is a function object, which releases one item. Count gives the number of elements.</td></tr>
		<tr><td><code>Iterator Index(TListIndex index) const;</code></td></tr>
		<tr><td><code>Iterator Begin() const;</code></td></tr>
		<tr><td><code>Iterator Next(Iterator node) const;</code></td></tr>
		<tr><td><code>Iterator Prev(Iterator node) const;</code></td></tr>
		<tr><td><code>Iterator Last() const;</code></td></tr>
		<tr><td>Index transforms an integer to an iterator. Begin, Next, Prev and Last iterate through the list step by step.</td></tr>
		<tr><td><code>template &lt;typename F&gt; bool ForEach(RefRef(F) rF = F()) const;</code></td></tr>
		<tr><td><code>template &lt;typename F&gt; bool ForEach(Ref(F) rF) const;</code></td></tr>
		<tr><td><code>template &lt;typename E&gt; Iterator Find(ConstPtr(Item) data, RefRef(E) rE = E()) const;</code></td></tr>
		<tr><td><code>template &lt;typename E&gt; Iterator Find(ConstPtr(Item) data, Ref(E) rE) const;</code></td></tr>
		<tr><td>ForEach supports traversing the list by using a function object of type F. Find searches the possibly unordered list and returns an iterator to the item found.</td></tr>
		<tr><td><code>Iterator FindSorted(ConstPtr(Item) data);</code></td></tr>
		<tr><td><code>template &lt;typename S&gt; Iterator FindSorted(ConstPtr(Item) data, Ref(S) rS);</code></td></tr>
		<tr><td><code>template &lt;typename S&gt; Iterator FindSorted(ConstPtr(Item) data, RefRef(S) rS = S());</code></td></tr>
		<tr><td><code>bool MatchSorted(Iterator it, ConstPtr(Item) data);</code></td></tr>
		<tr><td><code>template &lt;typename S&gt; bool MatchSorted(Iterator it, ConstPtr(Item) data, Ref(S) rS);</code></td></tr>
		<tr><td><code>template &lt;typename S&gt; bool MatchSorted(Iterator it, ConstPtr(Item) data, RefRef(S) rS = S());</code></td></tr>
		<tr><td><code>Iterator UpperBound(ConstPtr(Item) data) const;</code></td></tr>
		<tr><td><code>template &lt;typename S&gt; Iterator UpperBound(ConstPtr(Item) data, Ref(S) rS) const;</code></td></tr>
		<tr><td><code>template &lt;typename S&gt; Iterator UpperBound(ConstPtr(Item) data, RefRef(S) rS = S()) const;</code></td></tr>
		<tr><td><code>Iterator LowerBound(ConstPtr(Item) data) const;</code></td></tr>
		<tr><td><code>template &lt;typename S&gt; Iterator LowerBound(ConstPtr(Item) data, Ref(S) rS) const;</code></td></tr>
		<tr><td><code>template &lt;typename S&gt; Iterator LowerBound(ConstPtr(Item) data, RefRef(S) rS = S()) const;</code></td></tr>
		<tr><td><code>void Sort(TSortMode mode = HeapSortMode) const;</code></td></tr>
		<tr><td><code>template &lt;typename S&gt; void Sort(TSortMode mode = HeapSortMode, Ref(S) rS) const;</code></td></tr>
		<tr><td><code>template &lt;typename S&gt; void Sort(TSortMode mode = HeapSortMode, RefRef(S) rS = S()) const;</code></td></tr>
		<tr><td>FindSorted, UpperBound and LowerBound search the ordered list and return an iterator to the item found. Sort transforms an unordered list into an ordered one. S is a function object implementing a less algorithm.</td></tr>
		<tr><td><code>Iterator Append(ConstPtr(Item) data) const;</code></td></tr>
		<tr><td><code>Iterator Prepend(ConstPtr(Item) data) const;</code></td></tr>
		<tr><td><code>Iterator InsertBefore(Iterator node, ConstPtr(Item) data) const;</code></td></tr>
		<tr><td><code>Iterator InsertAfter(Iterator node, ConstPtr(Item) data) const;</code></td></tr>
		<tr><td><code>void Remove(Iterator node) const;</code></td></tr>
		<tr><td><code>template &lt;typename D&gt; void Remove(Iterator node, RefRef(D) rD = D()) const;</code></td></tr>
		<tr><td><code>template &lt;typename D&gt; void Remove(Iterator node, Ref(D) rD) const;</code></td></tr>
		<tr><td>Append, Prepend, InsertBefore, InsertAfter and Remove manipulate the list in an unordered fashion.</td></tr>
		<tr><td><code>Iterator InsertSorted(ConstPtr(Item) data) const;</code></td></tr>
		<tr><td><code>template &lt;typename S&gt; Iterator InsertSorted(ConstPtr(Item) data, Ref(S) rS) const;</code></td></tr>
		<tr><td><code>template &lt;typename S&gt; Iterator InsertSorted(ConstPtr(Item) data, RefRef(S) rS = S()) const;</code></td></tr>
		<tr><td><code>bool RemoveSorted(ConstPtr(Item) data) const;</code></td></tr>
		<tr><td><code>template &lt;typename S, typename D&gt; bool RemoveSorted(ConstPtr(Item) data, Ref(S) rS, Ref(D) rD) const;</code></td></tr>
		<tr><td><code>template &lt;typename S, typename D&gt; bool RemoveSorted(ConstPtr(Item) data, RefRef(S) rS, RefRef(D) rD) const;</code></td></tr>
		<tr><td>InsertSorted and RemoveSorted manipulate the list in an ordered way.</td></tr>
		<tr><td><code>ConstPtr(Item) GetData(Iterator node) const;</code></td></tr>
		<tr><td><code>void SetData(Iterator node, ConstPtr(Item) data) const;</code></td></tr>
		<tr><td>GetData and SetData implement an access to the data pointed to by the iterator.</td></tr>
	  </table>
	  <p>And sample code looks like this:</p>
<pre><code>
class X: public CCppObject
{
public:
	X() : m_name() {}
	X(CConstPointer name) : m_name(__FILE__LINE__ name) {}
	X(ConstRef(CStringBuffer) name) : m_name(name) {}
	ConstRef(CStringBuffer) get_Name() const { return m_name; }

protected:
	CStringBuffer m_name;
};

int main(void)
{
	auto f = [](ConstPtr(X) pA, ConstPtr(X) pB) &minus;&gt; bool { return pA&minus;&gt;get_Name().LT(pB&minus;&gt;get_Name()); };
	auto e = [](ConstPtr(X) pA, ConstPtr(X) pB) &minus;&gt; bool { return pA&minus;&gt;get_Name().EQ(pB&minus;&gt;get_Name()); };
	typedef CDataVectorT&lt;X, decltype(f)&gt; TXVector;
	TXVector dv(__FILE__LINE__ 16, 16, f, CCppObjectReleaseFunctor&lt;X&gt;());
	TXVector::Iterator it;
	X toFind(_T("ToFind"));

	dv.Append(new X(_T("Eins")));
	dv.Append(new X(_T("Zwei")));
	dv.Append(new X(_T("ToFind")));
	dv.Append(new X(_T("Vier")));
	it = dv.Find&lt;decltype(e)&gt;(&toFind, e);
	assert(it);
	assert((*it)&minus;&gt;get_Name().EQ(CStringLiteral(_T("ToFind"))));

	dv.Sort();
	it = dv.FindSorted(&toFind);
	assert(dv.MatchSorted(it, &toFind));
	assert((*it)&minus;&gt;get_Name().EQ(CStringLiteral(_T("ToFind"))));
	return 0;
}
</code></pre>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/okdevdo">okdevdo</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="../javascripts/scale.fix.js"></script>
    
  </body>
</html>
