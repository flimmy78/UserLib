<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
      "http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="UserLib is a C++ Library with a C-Kernel."> 
    <meta name="keywords" content="Library, C++"> 
    <meta name="robots" content="index|follow"> 
    <title>Userlib by okdevdo</title>

    <link rel="stylesheet" href="../stylesheets/styles.css">
    <link rel="stylesheet" href="../stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Modern C++</h1>
        <p><a href="http://en.wikipedia.org/wiki/C%2B%2B">C++</a> is one of the programming languages most used. It is standardized by <a href="https://isocpp.org/">ISO</a> organisation.</p>
		
        <ul>
          <li><a href="">Back</a></li>
          <li><a href="../index.html">Home</a></li>
          <li><a href="">Next</a></li>
        </ul>
      </header>
      <section>
	  <h2>Smart Pointers</h2>
	  <p>In the standard library of C++11 you find the following <a href="http://en.wikipedia.org/wiki/Smart_pointer">smart pointers</a>: unique_ptr, shared_ptr and weak_ptr. unique_ptr is an advancement of old auto_ptr. auto_ptr has a copy semantic, while unique_ptr has a modern move semantic. shared_ptr and weak_ptr implement the counted reference pointer idiom.</p>
	  <p>UserLib contains class <a href="../html/_cpp_object_8h_source.html">CCppObject</a>, which is the base class of all classes allocated on the heap.</p>
	  <h2>Containers</h2>
	  <p>The <a href="http://en.wikipedia.org/wiki/Standard_Template_Library">standard template library</a> supports four categories: containers, algorithms, functors and iterators. Containers can be divided into two groups: sequential and associative containers. Sequence containers include vector, deque, and list. Associative containers include set, multiset, map, and multimap.</p>
	  <p>UserLib contains several templated wrapper classes. Wrapper classes of a interface and implementation of data structures written in C. This list include <a href="../html/_data_vector_8h_source.html">CDataVector</a>, <a href="../html/_data_double_linked_list_8h_source.html">CDataDoubleLinkedList</a>, <a href="../html/_data_binary_tree_8h_source.html">CDataBinaryTree</a> and <a href="../html/_data_b_tree_8h_source.html">CDataBTree</a>. Each class defines its own iterator. And the set of methods forming the interface are very similar to each other. For example the interface of <a href="../html/_data_vector_8h_source.html">CDataVector</a> is as follows:</p>
	  <table>
		<tr><td><code>bool Open(TListCnt cnt, TListCnt exp);</code></td></tr>
		<tr><td><code>TListCnt Count() const;</code></td></tr>
		<tr><td><code>void Close(TDeleteFunc freeFunc = NULL, Pointer context = NULL);</code></td></tr>
		<tr><td><code>Iterator Index(TListIndex index) const { Iterator it = VectorIndex(_liste, index); return it; }</code></td></tr>
		<tr><td><code>Iterator Begin() const;</code></td></tr>
		<tr><td><code>Iterator Next(Iterator node) const;</code></td></tr>
		<tr><td><code>Iterator Prev(Iterator node) const;</code></td></tr>
		<tr><td><code>Iterator Last() const;</code></td></tr>
		<tr><td><code>bool ForEach(TForEachFunc func, Pointer context = NULL) const;</code></td></tr>
		<tr><td><code>Iterator Find(ConstPointer data, TSearchAndSortFunc findFunc) const;</code></td></tr>
		<tr><td><code>Iterator FindSorted(ConstPointer data, TSearchAndSortFunc findFunc = NULL) const;</code></td></tr>
		<tr><td><code>Iterator UpperBound(ConstPointer data, TSearchAndSortFunc findFunc) const;</code></td></tr>
		<tr><td><code>Iterator LowerBound(ConstPointer data, TSearchAndSortFunc findFunc) const;</code></td></tr>
		<tr><td><code>void Sort(TSearchAndSortFunc sortFunc = NULL, TSortMode mode = HeapSortMode) const;</code></td></tr>
		<tr><td><code>Iterator Append(ConstPointer data) const;</code></td></tr>
		<tr><td><code>Iterator Prepend(ConstPointer data) const;</code></td></tr>
		<tr><td><code>Iterator InsertBefore(Iterator node, ConstPointer data) const;</code></td></tr>
		<tr><td><code>Iterator InsertAfter(Iterator node, ConstPointer data) const;</code></td></tr>
		<tr><td><code>void Remove(Iterator node, TDeleteFunc freeFunc = NULL, Pointer context = NULL) const;</code></td></tr>
		<tr><td><code>Iterator InsertSorted(ConstPointer data, TSearchAndSortFunc findFunc = NULL) const;</code></td></tr>
		<tr><td><code>bool RemoveSorted(ConstPointer data, TSearchAndSortFunc findFunc = NULL, TDeleteFunc freeFunc = NULL, Pointer context = NULL) const;</code></td></tr>
		<tr><td><code>ConstPointer GetData(Iterator node) const;</code></td></tr>
		<tr><td><code>void SetData(Iterator node, ConstPointer data) const;</code></td></tr>
	  </table>
	  <p>And sample code looks like this:</p>
<pre><code>
void __stdcall XDeleteFunc( ConstPointer data, Pointer context )
{
	X* pInfo = CastAnyPtr(X, CastMutable(Pointer, data));

	pInfo->release();
}

sword __stdcall XSearchAndSortFunc( ConstPointer pa, ConstPointer pb)
{
	X* ppa = CastAnyPtr(X, CastMutable(Pointer, pa));
	X* ppb = CastAnyPtr(X, CastMutable(Pointer, pb));

	return (ppa->GetName().Compare(ppb->GetName()));
}

int main(int argc, char**argv)
{
	CDataVectorT<X> dv(16, 16);
	CDataVectorT<X>::Iterator it;
	X toFind;
	
	dv.Append(new X());
	...
	it = dv.Find(&toFind, XSearchAndSortFunc);
	...
	dv.Close(XDeleteFunc);
}
</code></pre>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/okdevdo">okdevdo</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="../javascripts/scale.fix.js"></script>
    
  </body>
</html>
